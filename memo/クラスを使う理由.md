# クラスを使う理由

プログラミングにおいて、クラスは「状態（データ）」と「振る舞い（ロジック）」を一つにまとめるための設計図のようなものです。

関数だけでも同じような機能は実現できますが、クラスを使うことで、特にプログラムが複雑になってきたときに多くのメリットがあります。

ここでは、簡単なカウンターを例に、関数のみで実装した場合とクラスを使った場合を比較してみましょう。

## 実装例

### 1. 関数のみで実装した場合

まずは、カウンターの状態と操作をそれぞれ別の関数で定義してみます。

```typescript
// /home/soma/workspace/express-tuto/memo/class-vs-function/function-based.ts

// カウンターの状態を定義する型
type CounterState = {
  count: number;
};

// カウンターを初期化する関数
const createCounter = (): CounterState => {
  return { count: 0 };
};

// カウンターの値を1増やす関数
const increment = (counter: CounterState): void => {
  counter.count++;
};

// カウンターの値を取得する関数
const getCount = (counter: CounterState): number => {
  return counter.count;
};

// --- 使用例 ---
const counter1 = createCounter();
increment(counter1);
increment(counter1);
console.log(`カウンター1の値: ${getCount(counter1)}`); // => カウンター1の値: 2

const counter2 = createCounter();
increment(counter2);
console.log(`カウンター2の値: ${getCount(counter2)}`); // => カウンター2の値: 1
```

このコードは問題なく動作します。しかし、いくつかの課題があります。

- **データとロジックが分離している**: `CounterState`というデータの型定義と、それを操作する`createCounter`、`increment`、`getCount`といった関数がバラバラに存在しています。これらがセットであることが、コードを一読しただけでは分かりにくいです。
- **間違った使い方をしやすい**: `increment`関数は`CounterState`型の引数をとりますが、間違えて関係のないオブジェクトを渡してしまう可能性があります。また、`counter1`の`count`プロパティに直接`counter1.count = 100`のように代入できてしまい、意図しない変更が加えられるリスクがあります。

### 2. クラスを使って実装した場合

次に、同じカウンター機能をクラスを使って実装してみます。

```typescript
// /home/soma/workspace/express-tuto/memo/class-vs-function/class-based.ts
class Counter {
  private count: number;

  constructor() {
    this.count = 0;
  }

  public increment(): void {
    this.count++;
  }

  public getCount(): number {
    return this.count;
  }
}

// --- 使用例 ---
const counter1 = new Counter();
counter1.increment();
counter1.increment();
console.log(`カウンター1の値: ${counter1.getCount()}`); // => カウンター1の値: 2

const counter2 = new Counter();
counter2.increment();
console.log(`カウンター2の値: ${counter2.getCount()}`); // => カウンター2の値: 1
```

### 関数ベースとの比較からわかるクラスのメリット

クラスを使った実装は、関数のみの実装と比べて以下のようなメリットがあります。

#### 1. 関連するデータとロジックを一つにまとめられる（カプセル化）

クラスを使うと、`count`という**データ（状態）**と、`increment`や`getCount`といった**ロジック（振る舞い）**を`Counter`という一つのまとまりとして扱うことができます。

これにより、コードの意図が明確になり、見通しが良くなります。カウンターに関する機能は`Counter`クラスを見ればすべて分かる、という状態になります。

#### 2. データを安全に保つことができる（情報隠蔽）

`count`プロパティに`private`というキーワードが付いていることに注目してください。これは、`count`が`Counter`クラスの**内部からしか**アクセスできないことを意味します。

クラスの外から`counter1.count = 100`のように直接値を書き換えることはできなくなり、`increment`メソッドを介してのみ値を変更できるようになります。これにより、意図しないデータの変更を防ぎ、バグの少ない安全なコードを書くことができます。

#### 3. 再利用しやすく、拡張しやすい

一度`Counter`クラスを作ってしまえば、`new Counter()`とするだけで、同じ機能を持つカウンターをいくつでも簡単に作成できます。

また、もし「2 ずつ増えるカウンター」や「減らすこともできるカウンター」が欲しくなったら、`Counter`クラスを**継承**して新しいクラスを作ることで、元のコードを再利用しつつ簡単に機能拡張ができます。

## まとめ

| 観点         | 関数ベース                               | クラスベース                      |
| :----------- | :--------------------------------------- | :-------------------------------- |
| **関連性**   | データとロジックがバラバラ               | データとロジックが一体化している  |
| **安全性**   | 外部からデータを直接変更できてしまう     | `private`でデータを保護できる     |
| **再利用性** | 関数を都度呼び出す必要がある             | `new`でインスタンスを簡単に作れる |
| **拡張性**   | 既存の関数をコピーして修正する必要がある | `継承`で差分だけを記述できる      |

簡単な処理であれば関数だけでも十分ですが、アプリケーションが大きくなり、扱うデータやロジックが複雑になってくると、クラスを使うことによる**整理整頓**、**安全性**、**再利用性**のメリットが非常に大きくなります。

これが、多くのプログラミング言語でクラスが重要な機能として採用されている理由です。
