# クラスと DI：Before/After 比較ドキュメント

このドキュメントでは、なぜソフトウェア開発でクラスと依存性の注入（DI）が推奨されるのかを、具体的なコードの比較を通じて解説します。

## シナリオ

「ユーザー ID を指定して、データベースからユーザー情報を取得する」というシンプルな機能を実装します。

---

## Before: DI を使わない密結合な実装

まず、DI を使わずに直接的な実装に依存したコードを見てみましょう。

### コード

```typescript
// データベースから直接データを取得するクラス
class MySqlUserRepository {
  findById(id: string) {
    console.log(`Finding user ${id} in MySQL...`);
    // 本来はDB接続処理
    return { id: id, name: "Taro Yamada (from MySQL)" };
  }
}

// ユーザー情報を取得するビジネスロジック
class UserUsecase {
  private userRepository: MySqlUserRepository;

  constructor() {
    // ★問題点: コンストラクタ内部で、具体的なクラスを直接インスタンス化している
    this.userRepository = new MySqlUserRepository();
  }

  execute(userId: string) {
    const user = this.userRepository.findById(userId);
    console.log(`User found: ${user.name}`);
  }
}

// 実行コード
const usecase = new UserUsecase();
usecase.execute("1");
```

### このコードの問題点

- **変更に弱い**: もしデータベースを MySQL から別のもの（例: PostgreSQL）に変更したい場合、`UserUsecase`クラスの`constructor`を直接書き換える必要があります。ビジネスロジックのクラスが、データアクセスの詳細な実装を知ってしまっている状態です。
- **テストがしにくい**: `UserUsecase`をテストしたいだけなのに、`MySqlUserRepository`、さらには本物のデータベース接続まで必要になってしまいます。単体テスト（ユニットテスト）を簡単に行えません。
- **再利用性が低い**: `UserUsecase`は`MySqlUserRepository`と固く結びついているため、他のデータソース（テスト用のモックなど）で再利用することができません。

---

## After: クラスと DI で疎結合な実装

次に、インターフェースを導入し、DI の考え方を使って改良したコードを見てみましょう。

### コード

#### 1. 契約（インターフェース）の定義

まず、「どんな機能を持つべきか」というルールだけを定義します。

```typescript:%2Fhome%2Fsoma%2Fworkspace%2Fec-backend%2Fsrc%2Fdi-example%2FIUserRepository.ts
// ユーザーリポジトリが満たすべき「契約」
export interface IUserRepository {
  findById(id: string): { id: string; name: string } | null;
}
```

#### 2. 具体的な実装の作成

次に、「契約」に従って具体的なクラスを実装します。

```typescript:%2Fhome%2Fsoma%2Fworkspace%2Fec-backend%2Fsrc%2Fdi-example%2FMySqlUserRepository.ts
// 本番用の実装
import { IUserRepository } from './IUserRepository';

export class MySqlUserRepository implements IUserRepository {
  findById(id: string) {
    console.log(`Finding user ${id} in MySQL...`);
    return { id: id, name: 'Taro Yamada (from MySQL)' };
  }
}
```

```typescript:%2Fhome%2Fsoma%2Fworkspace%2Fec-backend%2Fsrc%2Fdi-example%2FMockUserRepository.ts
// テスト用の実装
import { IUserRepository } from './IUserRepository';

export class MockUserRepository implements IUserRepository {
  findById(id: string) {
    console.log(`Finding user ${id} in Mock DB...`);
    return { id: id, name: 'Test User (from Mock)' };
  }
}
```

#### 3. DI で利用する側の実装

ビジネスロジックは、具体的なクラスではなく「契約（インターフェース）」に依存します。

```typescript:%2Fhome%2Fsoma%2Fworkspace%2Fec-backend%2Fsrc%2Fdi-example%2FUserUsecase.ts
import { IUserRepository } from './IUserRepository';

export class UserUsecase {
  // ★改善点: 具体的な実装ではなく、インターフェースに依存
  constructor(private readonly userRepository: IUserRepository) {}

  execute(userId: string) {
    const user = this.userRepository.findById(userId);
    if (user) {
      console.log(`User found: ${user.name}`);
    }
  }
}
```

#### 4. 実行コード（依存性の注入）

最後に、利用する側（`UserUsecase`）と使われる側（`MySqlUserRepository`など）を組み立てます。

```typescript:%2Fhome%2Fsoma%2Fworkspace%2Fec-backend%2Fsrc%2Fdi-example%2Fmain.ts
import { UserUsecase } from './UserUsecase';
import { MySqlUserRepository } from './MySqlUserRepository';
import { MockUserRepository } from './MockUserRepository';

// ★改善点: 使うオブジェクトを「あとから注入」している

// 本番環境ではMySQLのリポジトリを注入
console.log('--- Running with Production DB ---');
const mySqlRepo = new MySqlUserRepository();
const usecaseWithMySql = new UserUsecase(mySqlRepo);
usecaseWithMySql.execute('1');

// テスト環境ではモックのリポジトリを注入
console.log('\n--- Running with Mock DB ---');
const mockRepo = new MockUserRepository();
const usecaseWithMock = new UserUsecase(mockRepo);
usecaseWithMock.execute('1');
```

### このコードの利点

- **変更に強い**: DB を PostgreSQL に変更したくなっても、`UserUsecase`のコードには一切触る必要がありません。新しい`PostgresUserRepository`を作り、`main.ts`で注入するオブジェクトを差し替えるだけです。
- **テストが容易**: `UserUsecase`のテストをする際は、本物の DB が不要な`MockUserRepository`を注入すれば、ビジネスロジックだけに集中したテストが簡単にできます。
- **高い再利用性**: `UserUsecase`は特定の DB 実装から解放されたため、どんな`IUserRepository`の実装とでも組み合わせることができ、非常に再利用しやすくなりました。

## まとめ

DI は、クラスという「部品」を直接組み立てるのではなく、インターフェースという「共通の接続規格」を介して組み合わせる設計思想です。

これにより、各部品の独立性が高まり、柔軟で、テストしやすく、メンテナンス性に優れたソフトウェアを構築することができます。
 